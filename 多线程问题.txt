volatile与synchronized区别？
volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取，每次修改值都会强制刷新主内存.
volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.
volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.
volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.


公平锁和非公平锁 就是其中一个线程释放锁的时候，其他线程获取的机会 是否是均等的
公平锁就是 谁加锁早 谁获得锁
非公平锁 就是 其他线程都有机会获得锁，不管你是否比其他线程早

互斥锁 自旋锁

一个是互斥同步 还有一个是锁
同步 就是synchronized
锁就是lock

你说的互斥锁 应该说的是synchronized
synchronized加锁 需要让操作系统协助处理，也就是资料常说的 转入内核态

性能差 为了优化synchronized性能 才有 偏向锁-轻量级锁-自旋锁的概念
这些都是为了优化synchronized的性能
synchronized先加偏向锁
如果有竞争 就升级为轻量级锁或者重量级锁
重量级就是转入内核态处理了
因为java虚拟机 可能会认为可以能自旋一定的次数 其他线程就处理完了 释放锁了
我就能加了
那些 对synchronized的优化都是为了 减少进入内核态的次数